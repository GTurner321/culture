<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virus Spread Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f8ff;
            min-height: 100vh;
            overflow-y: auto;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(40, 1fr);
            width: 100%;
            gap: 0;
        }

        .cell {
            aspect-ratio: 1;
            transition: background-color 0.3s ease;
        }

        /* State colors with subtle blue progression */
        .s1 { background-color: #f0f8ff; } /* Background */
        .s2 { background-color: #f0f8ff; } /* Background */
        .s3 { background-color: #e0ebf5; } /* Light blue */
        .s4 { background-color: #d0e1f2; } /* Slightly darker */
        .s5 { background-color: #c0d7ef; } /* Slightly darker still */
        .s6 { background-color: #e0ebf5; } /* Same as S3 */
        .s7 { background-color: #f0f8ff; } /* Background */
    </style>
</head>
<body>
    <div id="grid"></div>

    <script>
        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.state = 1; // Start with S1
                this.element = document.createElement('div');
                this.element.className = 'cell s1';
                this.isMarked = false;
            }

            setState(newState) {
                // If marked and about to transition to S7, stay at S6
                if (this.isMarked && newState === 7) {
                    newState = 6;
                }
                this.state = newState;
                this.element.className = `cell s${newState}`;
            }

            setMarked() {
                this.isMarked = true;
            }
        }

        class Grid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cells = [];
                this.gridElement = document.getElementById('grid');
                this.initialize();
                this.markRandomCells();
            }

            initialize() {
                // Create all cells
                for (let y = 0; y < this.height; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        const cell = new Cell(x, y);
                        this.cells[y][x] = cell;
                        this.gridElement.appendChild(cell.element);
                    }
                }
            }

            getRandomCell() {
                const y = Math.floor(Math.random() * this.height);
                const x = Math.floor(Math.random() * this.width);
                return this.cells[y][x];
            }

            markRandomCells() {
                // Mark 60 random cells anywhere in the grid
                let markedCount = 0;
                while (markedCount < 60) {
                    const cell = this.getRandomCell();
                    if (!cell.isMarked) {
                        cell.setMarked();
                        markedCount++;
                    }
                }
            }

            getNeighbors(x, y, isDiagonal) {
                const neighbors = [];
                const directions = isDiagonal ? 
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] : // Diagonal neighbors
                    [[-1, 0], [1, 0], [0, -1], [0, 1]];    // Direct neighbors

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX >= 0 && newX < this.width && newY >= 0 && newY < this.height) {
                        neighbors.push(this.cells[newY][newX]);
                    }
                }
                return neighbors;
            }

            hasInfectiousCells() {
                return this.cells.some(row => 
                    row.some(cell => cell.state >= 2 && cell.state <= 6)
                );
            }

            allCellsInS1orS7() {
                return this.cells.every(row =>
                    row.every(cell => cell.state === 1 || cell.state === 7)
                );
            }

            update() {
                const newStates = this.cells.map((row, y) => 
                    row.map(cell => {
                        switch (cell.state) {
                            case 1: // S1 (Non-infected)
                                if (this.allCellsInS1orS7()) {
                                    // Initial infection only in first 8 rows
                                    if (y < 8) {
                                        return Math.random() < 1/200 ? 2 : 1;
                                    }
                                    return 1;
                                } else if (this.hasInfectiousCells()) {
                                    // Check for direct neighboring infections (1/9 chance)
                                    const directInfectiousNeighbors = this.getNeighbors(cell.x, cell.y, false)
                                        .filter(n => n.state >= 2 && n.state <= 5);
                                    
                                    // Check for diagonal neighboring infections (1/12 chance)
                                    const diagonalInfectiousNeighbors = this.getNeighbors(cell.x, cell.y, true)
                                        .filter(n => n.state >= 2 && n.state <= 5);
                                    
                                    if (directInfectiousNeighbors.length > 0 && Math.random() < 1/9) {
                                        return 2;
                                    }
                                    if (diagonalInfectiousNeighbors.length > 0 && Math.random() < 1/12) {
                                        return 2;
                                    }
                                    return 1;
                                }
                                return 1;
                            case 2: return 3; // S2 -> S3
                            case 3: return 4; // S3 -> S4
                            case 4: return 5; // S4 -> S5
                            case 5: return 6; // S5 -> S6
                            case 6: 
                                // Only progress to S7 if not marked
                                return cell.isMarked ? 6 : 7;
                            case 7: return 7; // S7 stays S7
                            default: return cell.state;
                        }
                    })
                );

                // Apply new states
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.cells[y][x].setState(newStates[y][x]);
                    }
                }
            }
        }

        // Create and start the simulation with 0.25-second intervals
        const grid = new Grid(40, 240);
        setInterval(() => grid.update(), 150);
    </script>
</body>
</html>
