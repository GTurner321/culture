<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virus Spread Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f8ff;
            min-height: 100vh;
            overflow-y: auto;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(30, 1fr);
            width: 100%;
            gap: 0;
        }

        .cell {
            aspect-ratio: 1;
            transition: background-color 0.3s ease;
        }

        /* State colors - with more subtle progression */
        .s1 { background-color: #f0f8ff; } /* Non-infected (very pale light blue) */
        .s2 { background-color: #d0e1f2; } /* Infected and infectious (slightly darker) */
        .s3 { background-color: #b0c4e6; } /* More infected (slightly darker still) */
        .s4 { background-color: #d0e1f2; } /* Infected but not infectious */
        .s5 { background-color: #f0f8ff; } /* Recovered */
    </style>
</head>
<body>
    <div id="grid"></div>

    <script>
        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.state = 1; // Start with S1
                this.element = document.createElement('div');
                this.element.className = 'cell s1';
            }

            setState(newState) {
                this.state = newState;
                this.element.className = `cell s${newState}`;
            }
        }

        class Grid {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.cells = [];
                this.gridElement = document.getElementById('grid');
                this.initialize();
            }

            initialize() {
                // Create all cells
                for (let y = 0; y < this.height; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        const cell = new Cell(x, y);
                        this.cells[y][x] = cell;
                        this.gridElement.appendChild(cell.element);
                    }
                }
            }

            getNeighbors(x, y, isDiagonal) {
                const neighbors = [];
                const directions = isDiagonal ? 
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] : // Diagonal neighbors
                    [[-1, 0], [1, 0], [0, -1], [0, 1]];    // Direct neighbors

                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX >= 0 && newX < this.width && newY >= 0 && newY < this.height) {
                        neighbors.push(this.cells[newY][newX]);
                    }
                }
                return neighbors;
            }

            hasInfectiousCells() {
                return this.cells.some(row => 
                    row.some(cell => cell.state === 2 || cell.state === 3 || cell.state === 4)
                );
            }

            update() {
                const newStates = this.cells.map((row, y) => 
                    row.map(cell => {
                        switch (cell.state) {
                            case 1: // S1 (Non-infected)
                                if (!this.hasInfectiousCells()) {
                                    // Random infection only in top 20 lines when no infectious cells exist
                                    if (y < 20) {
                                        return Math.random() < 1/200 ? 2 : 1;
                                    }
                                    return 1;
                                } else {
                                    // Check for direct neighboring infections (1/4 chance)
                                    const directInfectiousNeighbors = this.getNeighbors(cell.x, cell.y, false)
                                        .filter(n => n.state === 2 || n.state === 3);
                                    
                                    // Check for diagonal neighboring infections (1/6 chance)
                                    const diagonalInfectiousNeighbors = this.getNeighbors(cell.x, cell.y, true)
                                        .filter(n => n.state === 2 || n.state === 3);
                                    
                                    if (directInfectiousNeighbors.length > 0 && Math.random() < 1/4) {
                                        return 2;
                                    }
                                    if (diagonalInfectiousNeighbors.length > 0 && Math.random() < 1/6) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            case 2: return 3; // S2 -> S3
                            case 3: return 4; // S3 -> S4
                            case 4: return 5; // S4 -> S5
                            case 5: return 5; // S5 stays S5
                            default: return cell.state;
                        }
                    })
                );

                // Apply new states
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.cells[y][x].setState(newStates[y][x]);
                    }
                }
            }
        }

        // Create and start the simulation with 200 rows
        const grid = new Grid(30, 200);
        setInterval(() => grid.update(), 1000);
    </script>
</body>
</html>
